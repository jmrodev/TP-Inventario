<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestión de Menús en Aplicaciones CLI (POO PHP)</title>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { max-width: 900px; margin: auto; background: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1, h2, h3 { color: #0056b3; }
        pre { background: #e9e9e9; padding: 15px; border-radius: 5px; overflow-x: auto; }
        code { font-family: "Courier New", Courier, monospace; background: #e9e9e9; padding: 2px 4px; border-radius: 3px; }
        .method-section { margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 15px; }
        .method-section:last-child { border-bottom: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Gestión de Menús en Aplicaciones CLI (POO PHP)</h1>
        <p>En el desarrollo de aplicaciones de línea de comandos (CLI) con PHP y Programación Orientada a Objetos (POO), la gestión de menús es un componente fundamental para la interacción con el usuario. Este documento explora el enfoque recomendado para manejar las opciones de un menú, destacando sus ventajas.</p>

        <h2>Gestión de Menú Dinámica con Callables (Enfoque Recomendado)</h2>
        <p>Este enfoque es robusto y flexible, ideal para menús que pueden crecer o cambiar. Se basa en asociar cada opción no solo con una descripción, sino también con una acción (por ejemplo, una función o un método) que se ejecutará.</p>

        <h3>Concepto</h3>
        <p>En lugar de solo almacenar descripciones, el array <code>$opciones</code> puede almacenar pares de clave-valor donde la clave es el número de la opción y el valor es un array asociativo que contiene tanto la descripción como la acción a ejecutar (por ejemplo, un "callback" o una referencia a una función/método).</p>

        <h3>Modificación de la Clase <code>Menu</code> (Ejemplo Conceptual)</h3>
        <p>Para implementar esto, la propiedad <code>$opciones</code> y el método <code>ejecutarOpcion</code> necesitan ser modificados para manejar la estructura de opciones con callables. La clase <code>Menu</code> ya está diseñada para esto.</p>

        <h4>Definición de Opciones (en <code>Main.php</code> o similar)</h4>
        <pre><code>// Definir las opciones del menú principal con acciones asociadas
$opcionesMenuPrincipal = [
    1 => ['descripcion' => 'Añadir Repuesto', 'accion' => function() {
        echo "Ejecutando la función para añadir un repuesto (desde un callback)...\n";
        // Aquí iría la llamada a la función o método real para añadir repuestos
    }],
    2 => ['descripcion' => 'Listar Repuestos', 'accion' => function() {
        echo "Ejecutando la función para listar repuestos (desde un callback)...\n";
        // Aquí iría la llamada a la función o método real para listar repuestos
    }],
    3 => ['descripcion' => 'Salir', 'accion' => function() {
        echo "Saliendo de la aplicación...\n";
    }]
];

// Crear una instancia del menú
// $menuPrincipal = new Menu("Menú Principal de Inventario", $opcionesMenuPrincipal);
</code></pre>

        <h4>Método <code>ejecutarOpcion</code> (sin cambios, ya soporta callables)</h4>
        <p>La belleza de este enfoque es que el método <code>ejecutarOpcion</code> no necesita cambios, ya que <code>is_callable()</code> y <code>call_user_func()</code> de PHP son lo suficientemente flexibles como para manejar tanto funciones anónimas como arrays <code>[$objeto, 'nombreMetodo']</code>.</p>
        <pre><code>public function ejecutarOpcion($seleccion) {
    if (array_key_exists($seleccion, $this->opciones)) {
        $opcionSeleccionada = $this->opciones[$seleccion];
        $descripcion = $opcionSeleccionada['descripcion'];
        $accion = $opcionSeleccionada['accion']; // Obtenemos la acción asociada

        echo "Ha seleccionado: " . $descripcion . "\n";

        // Ejecutamos la acción (si es un callable)
        if (is_callable($accion)) {
            call_user_func($accion); // Ejecuta la función anónima o callback
        } else {
            echo "La acción para '" . $descripcion . "' no es ejecutable.\n";
        }

        if ($descripcion === 'Salir') {
            return false; // Indica que el menú debe detenerse
        }
    } else {
        echo "Opción inválida. Por favor, intente de nuevo.\n";
    }
    return true; // Indica que el menú debe continuar
}</code></pre>

        <h3>Ventajas</h3>
        <ul>
            <li><strong>Dinamismo y Flexibilidad:</strong> Las opciones y sus acciones pueden ser definidas y modificadas fácilmente sin alterar la lógica central del menú.</li>
            <li><strong>Bajo Acoplamiento:</strong> La clase <code>Menu</code> no necesita saber los detalles de cada acción; simplemente las ejecuta. Esto promueve un diseño más modular.</li>
            <li><strong>Escalabilidad:</strong> Añadir nuevas opciones es tan simple como agregar un nuevo elemento al array <code>$opciones</code>.</li>
            <li><strong>Reutilización:</strong> Las funciones o métodos que realizan las acciones pueden ser reutilizados en otras partes de la aplicación.</li>
        </ul>

        <h3>Uso de Métodos de Objeto como Acciones</h3>
        <p>Una extensión natural del enfoque dinámico es asociar las opciones del menú con métodos de objetos específicos. Esto es particularmente útil en POO, ya que permite que cada acción esté encapsulada dentro de la clase o clases responsables de esa funcionalidad.</p>

        <h4>Concepto</h4>
        <p>En lugar de una función anónima, la 'acción' en el array <code>$opciones</code> puede ser un array que especifique un objeto y el nombre de uno de sus métodos (<code>[$objeto, 'nombreMetodo']</code>). PHP permite llamar a estos "callables" de la misma manera que a las funciones anónimas.</p>

        <h4>Ejemplo: Clase <code>ManejadorInventario</code> (Conceptual)</h4>
        <p>Aunque la clase <code>ManejadorInventario</code> fue eliminada del proyecto actual, conceptualmente, así es como se integrarían sus métodos como acciones del menú:</p>
        <pre><code>class ManejadorInventario {
    // ... constructor y propiedades ...

    public function añadirRepuesto() {
        echo "Lógica para añadir un nuevo repuesto (desde ManejadorInventario::añadirRepuesto)...
";
    }

    public function listarRepuestos() {
        echo "Lógica para listar todos los repuestos (desde ManejadorInventario::listarRepuestos)...
";
    }

    public function salirAplicacion() {
        echo "Cerrando la aplicación de inventario (desde ManejadorInventario::salirAplicacion)...
";
    }
}

// Ejemplo de cómo se definirían las opciones si ManejadorInventario existiera:
// $manejador = new ManejadorInventario($db);
// $opcionesMenuPrincipal = [
//     1 => ['descripcion' => 'Añadir Repuesto', 'accion' => [$manejador, 'añadirRepuesto']],
//     2 => ['descripcion' => 'Listar Repuestos', 'accion' => [$manejador, 'listarRepuestos']],
//     3 => ['descripcion' => 'Salir', 'accion' => [$manejador, 'salirAplicacion']]
// ];
</code></pre>

        <h4>Método <code>ejecutarOpcion</code> (sin cambios, ya soporta callables)</h4>
        <p>La belleza de este enfoque es que el método <code>ejecutarOpcion</code> que ya hemos visto no necesita cambios, ya que <code>is_callable()</code> y <code>call_user_func()</code> de PHP son lo suficientemente flexibles como para manejar tanto funciones anónimas como arrays <code>[$objeto, 'nombreMetodo']</code>.</p>
        <pre><code>public function ejecutarOpcion($seleccion) {
    if (array_key_exists($seleccion, $this->opciones)) {
        $opcionSeleccionada = $this->opciones[$seleccion];
        $descripcion = $opcionSeleccionada['descripcion'];
        $accion = $opcionSeleccionada['accion'];

        echo "Ha seleccionado: " . $descripcion . "\n";

        if (is_callable($accion)) {
            call_user_func($accion); // Esto ejecutará el método del objeto
        } else {
            echo "La acción para '" . $descripcion . "' no es ejecutable.\n";
        }

        if ($descripcion === 'Salir') {
            return false;
        }
    } else {
        echo "Opción inválida. Por favor, intente de nuevo.\n";
    }
    return true;
}</code></pre>

        <h3>Ventajas Adicionales de Usar Métodos de Objeto</h3>
        <ul>
            <li><strong>Encapsulamiento:</strong> La lógica de cada acción está contenida dentro de su propia clase, mejorando la organización del código.</li>
            <li><strong>Cohesión:</strong> Las clases se vuelven más cohesivas, ya que agrupan funcionalidades relacionadas.</li>
            <li><strong>Reutilización y Mantenibilidad:</strong> Facilita la reutilización de la lógica de negocio y simplifica el mantenimiento al tener responsabilidades claras.</li>
        </ul>

        <h2>Conclusión</h2>
        <p>El enfoque dinámico utilizando un array de opciones con acciones asociadas (callbacks) es significativamente más potente y escalable para aplicaciones POO en PHP. Este método promueve un código más limpio, modular y fácil de mantener a largo plazo.</p>
    </div>
</body>
